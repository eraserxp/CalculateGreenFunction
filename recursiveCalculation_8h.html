<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CalculateGreenFunction: /home/pxiang/workspace_new/CalculateGreenFunction/src/recursiveCalculation/recursiveCalculation.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>/home/pxiang/workspace_new/CalculateGreenFunction/src/recursiveCalculation/recursiveCalculation.h File Reference</h1><code>#include &quot;<a class="el" href="types_8h-source.html">../Utility/types.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="basis_8h-source.html">../basis_set/basis.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="binaryIO_8h-source.html">../IO/binaryIO.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="formMatrix_8h-source.html">../formMatrix/formMatrix.h</a>&quot;</code><br>

<p>
<a href="recursiveCalculation_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRecursionData.html">RecursionData</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="recursiveCalculation_8h.html#09bb0743532eb10149446411001b1a13">deleteMatrixFiles</a> (std::string files)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="recursiveCalculation_8h.html#f519514f8f6d6155af66d593f73e4e1d">solveDenseLinearEqs</a> (<a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;A, <a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;B, <a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;X)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="recursiveCalculation_8h.html#3e2393074b4d4555969137b2abaae8dd">findCorrespondingVK</a> (<a class="el" href="classLatticeShape.html">LatticeShape</a> &amp;lattice, int maxDistance, <a class="el" href="classBasis.html">Basis</a> &amp;basis)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="recursiveCalculation_8h.html#6ae3e59ab41f6710e7d84c7ff3e98eef">getBasisIndexInVK</a> (<a class="el" href="classLatticeShape.html">LatticeShape</a> &amp;lattice, int K, <a class="el" href="classBasis.html">Basis</a> &amp;basis)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="recursiveCalculation_8h.html#cfed0b2a759fecb4de581223ec6b5a29">setUpRecursion</a> (<a class="el" href="classLatticeShape.html">LatticeShape</a> &amp;lattice, <a class="el" href="structInteractionData.html">InteractionData</a> &amp;interactionData, <a class="el" href="classBasis.html">Basis</a> &amp;initialSites, <a class="el" href="structRecursionData.html">RecursionData</a> &amp;rd)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="recursiveCalculation_8h.html#8da3dfb029980c8d340e6b15fc4aefc3">fromRightToCenter</a> (<a class="el" href="structRecursionData.html">RecursionData</a> &amp;recursionData, <a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a> z, <a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;AKRightStop, bool saveAMatrices=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="recursiveCalculation_8h.html#37b7dd15b0d491f5c830153780c3b0b9">fromLeftToCenter</a> (<a class="el" href="structRecursionData.html">RecursionData</a> &amp;recursionData, <a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a> z, <a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;ATildeKLeftStop, bool saveAMatrices=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="recursiveCalculation_8h.html#e097b7a86f8594f1b00c6f8c99c17a08">solveVKCenter</a> (<a class="el" href="structRecursionData.html">RecursionData</a> &amp;recursionData, <a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a> z, <a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;ATildeKLeftStop, <a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;AKRightStop, <a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;VKCenter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="recursiveCalculation_8h.html#606df39775b7266829a71b5550656fb1">calculateDensityOfState</a> (<a class="el" href="classLatticeShape.html">LatticeShape</a> &amp;lattice, <a class="el" href="classBasis.html">Basis</a> &amp;initialSites, <a class="el" href="structInteractionData.html">InteractionData</a> &amp;interactionData, const std::vector&lt; <a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a> &gt; &amp;zList, std::vector&lt; double &gt; &amp;rhoList)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="recursiveCalculation_8h.html#785526870b794d5138028250473ddeaa">calculateGreenFunc</a> (<a class="el" href="classLatticeShape.html">LatticeShape</a> &amp;lattice, <a class="el" href="classBasis.html">Basis</a> &amp;finalSites, <a class="el" href="classBasis.html">Basis</a> &amp;initialSites, <a class="el" href="structInteractionData.html">InteractionData</a> &amp;interactionData, const std::vector&lt; <a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a> &gt; &amp;zList, std::vector&lt; <a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a> &gt; &amp;gfList)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="606df39775b7266829a71b5550656fb1"></a><!-- doxytag: member="recursiveCalculation.h::calculateDensityOfState" ref="606df39775b7266829a71b5550656fb1" args="(LatticeShape &amp;lattice, Basis &amp;initialSites, InteractionData &amp;interactionData, const std::vector&lt; dcomplex &gt; &amp;zList, std::vector&lt; double &gt; &amp;rhoList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculateDensityOfState           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLatticeShape.html">LatticeShape</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lattice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBasis.html">Basis</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>initialSites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInteractionData.html">InteractionData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interactionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>zList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhoList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
calculate density of state at the initial sites 
</div>
</div><p>
<a class="anchor" name="785526870b794d5138028250473ddeaa"></a><!-- doxytag: member="recursiveCalculation.h::calculateGreenFunc" ref="785526870b794d5138028250473ddeaa" args="(LatticeShape &amp;lattice, Basis &amp;finalSites, Basis &amp;initialSites, InteractionData &amp;interactionData, const std::vector&lt; dcomplex &gt; &amp;zList, std::vector&lt; dcomplex &gt; &amp;gfList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculateGreenFunc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLatticeShape.html">LatticeShape</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lattice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBasis.html">Basis</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>finalSites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBasis.html">Basis</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>initialSites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInteractionData.html">InteractionData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interactionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>zList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gfList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
calculate all the matrix elements of the Green function &lt;final_sites| G(z) |initial_sites&gt; for a list of z values 
</div>
</div><p>
<a class="anchor" name="09bb0743532eb10149446411001b1a13"></a><!-- doxytag: member="recursiveCalculation.h::deleteMatrixFiles" ref="09bb0743532eb10149446411001b1a13" args="(std::string files)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deleteMatrixFiles           </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>files</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
clean up binary files that are used to save the matrices 
</div>
</div><p>
<a class="anchor" name="3e2393074b4d4555969137b2abaae8dd"></a><!-- doxytag: member="recursiveCalculation.h::findCorrespondingVK" ref="3e2393074b4d4555969137b2abaae8dd" args="(LatticeShape &amp;lattice, int maxDistance, Basis &amp;basis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int findCorrespondingVK           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLatticeShape.html">LatticeShape</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lattice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBasis.html">Basis</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find out which V_{K} the basis belongs to 
</div>
</div><p>
<a class="anchor" name="37b7dd15b0d491f5c830153780c3b0b9"></a><!-- doxytag: member="recursiveCalculation.h::fromLeftToCenter" ref="37b7dd15b0d491f5c830153780c3b0b9" args="(RecursionData &amp;recursionData, dcomplex z, CDMatrix &amp;ATildeKLeftStop, bool saveAMatrices=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fromLeftToCenter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRecursionData.html">RecursionData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>recursionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a>&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ATildeKLeftStop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>saveAMatrices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
recursive calculation from the left boundary to the center<p>
must call setUpRecursion before calling this function 
<p>
The recursive relation is given by: W_{K}*V_{K} = alpha_{K}*V_{K-maxDistance} + beta_{K}*V_{K+maxDistance} where V_{K} = [v_{K}, v_{K+1}, ..., v_{K+maxDistance-1}] and v_{K} is composed of the Green's functions whose parameters adds up to K (for example in 1D, v_{5} is [G(0,5), G(1,4), G(2, 3)] )<p>
At the left-most end, the index K = KLeftStart = Kmin = 1;<p>
V_{1} = [v_1, v_2, ..., v_{maxDistance}], V_{maxDistance+1} = [v_{maxDistance+1}, v_{maxDistance+2}, ..., v_{2*maxDistance}], V_{2*maxDistance+1} = [..., V_{3*maxDistance}] V_{(N-1)*maxDistance+1} = [..., V_{N*maxDistance}]<p>
Assuming V_{K-maxDistance} = 0 in the recursive relation for K=KLeftStart, we obtain: W_{KLeftStart}*V_{KLeftStart} = beta_{KLeftStart}*V_{KLeftStart+maxDistance} Based on the definition: V_{K} = ATilde_{K} * V_{K+maxDistance}, we obtain: W_{KLeftStart} * ATilde_{KLeftStart} = beta_{KLeftStart}<p>
This equation can be solved to give ATilde_{KLeftStart}<p>
W_{K}*V_{K} = alpha_{K}*V_{K-maxDistance} + beta_{K}*V_{K+maxDistance} let's simplify the notation: W_{K}*V_{K} = alpha_{K}*V_{K-} + beta_{K}*V_{K+}<p>
Now knowing the A_{KLeftStart} or ATildeKMinus, we can recursively calculate ATilde, ... until ATildeKLeftStop<p>
Start with the recursion relation W_{K}*V_{K} = alpha_{K}*V_{K-} + beta_{K}*V_{K+}<p>
Once we know ATilde_{K-}, we can express V_{K-} in terms of V_{K}, that is, V_{K-} = ATilde_{K-}*V_{K}. Substituting this into the above recursion relation, we obtain: W_{K}*V_{K} = alpha_{K}*ATilde_{K-}*V_{K} + beta_{K}*V_{K+}.<p>
Because of V_{K} = ATilde_{K} V_{K+}, the above equation can be rewritten as W_{K}*ATilde_{K} V_{K+} = alpha_{K}*ATilde_{K-}*ATilde_{K} V_{K+} + beta_{K}*A_{K+} . Therefore, W_{K}*ATilde_{K} = alpha_{K}*ATilde_{K-}*ATilde_{K} + beta_{K}<p>
==&gt; ( W_{K} - alpha_{K}*ATilde_{K-} ) * ATilde_{K} = beta_{K}<p>
Then ATilde_{K} can be obtained by solving the above linear equations 
</div>
</div><p>
<a class="anchor" name="8da3dfb029980c8d340e6b15fc4aefc3"></a><!-- doxytag: member="recursiveCalculation.h::fromRightToCenter" ref="8da3dfb029980c8d340e6b15fc4aefc3" args="(RecursionData &amp;recursionData, dcomplex z, CDMatrix &amp;AKRightStop, bool saveAMatrices=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fromRightToCenter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRecursionData.html">RecursionData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>recursionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a>&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>AKRightStop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>saveAMatrices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
recursive calculation from right boundary to the center<p>
must call setUpRecursion before calling this function 
<p>
The recursive relation is given by: W_{K}*V_{K} = alpha_{K}*V_{K-maxDistance} + beta_{K}*V_{K+maxDistance} where V_{K} = [v_{K}, v_{K+1}, ..., v_{K+maxDistance-1}] and v_{K} is composed of the Green's functions whose parameters adds up to K (for example in 1D, v_{5} is [G(0,5), G(1,4), G(2, 3)] )<p>
At the right-most end, the index K = KRightStart. But KRightStart is not necessarily equal to Kmax (the largest value that K can take). What we can say is that Kmax is one of {KRightStop, KRightStop+1, ..., KRightStop+maxDistance-1}. Similarly, KRightStop-1 is not necessarily equal to the summation of initial indexes. For example, in 1D, we want to calculate G(n, m, n', m'), Kc = n' + m', but KRightStop may be != Kc + 1. We can only say that V_{KRightStop-1} contains v_{Kc} (that is why the recursive calculation from right must stop at KRightStop)<p>
For the convenience of calculation, we may let the Kmax to be (N*maxDistance) so that all v_{K} from v_1 to v_Kmax can be divided into V_{1} = [v_1, v_2, ..., v_{maxDistance}], V_{maxDistance+1} = [v_{maxDistance+1}, v_{maxDistance+2}, ..., v_{2*maxDistance}], V_{2*maxDistance+1} = [..., V_{3*maxDistance}] V_{(N-1)*maxDistance+1} = [..., V_{N*maxDistance}]<p>
Assuming V_{K+maxDistance} = 0 in the recursive relation for K=KRightStart, we obtain: W_{KRightStart}*V_{KRightStart} = alpha_{KRightStart}*V_{KRightStart-maxDistance} Based on the definition: V_{K} = A_{K} * V_{K-maxDistance}, we obtain: W_{KRightStart} * A_{KRightStart} = alpha_{KRightStart}<p>
This equation can be solved to give A_{KRightStart}<p>
W_{K}*V_{K} = alpha_{K}*V_{K-maxDistance} + beta_{K}*V_{K+maxDistance} let's simplify the notation: W_{K}*V_{K} = alpha_{K}*V_{K-} + beta_{K}*V_{K+}<p>
Now knowing the A_{KRightStart} or AKPlus, we can recursively calculate AK, AKMinus, ... until AKRightStop<p>
Start with the recursion relation W_{K}*V_{K} = alpha_{K}*V_{K-} + beta_{K}*V_{K+}<p>
Once we know A_{K+}, we can express V_{K+} in terms of V_{K}, that is, V_{K+} = A_{K+}*V_{K}. Substituting this into the above recursion relation, we obtain: W_{K}*V_{K} = alpha_{K}*V_{K-} + beta_{K}*A_{K+}*V_{K}.<p>
Because of V_{K} = A_{K} V_{K-}, the above equation can be rewritten as W_{K}*A_{K}*V_{K-} = alpha_{K}*V_{K-} + beta_{K}*A_{K+}*A_{K}*V_{K} . Therefore, W_{K}*A_{K} = alpha_{K} + beta_{K}*A_{K+}*A_{K}<p>
==&gt; ( W_{K} - beta_{K}*A_{K+} ) * A_{K} = alpha_{K}<p>
Then A_{K} can be obtained by solving the above linear equations 
</div>
</div><p>
<a class="anchor" name="6ae3e59ab41f6710e7d84c7ff3e98eef"></a><!-- doxytag: member="recursiveCalculation.h::getBasisIndexInVK" ref="6ae3e59ab41f6710e7d84c7ff3e98eef" args="(LatticeShape &amp;lattice, int K, Basis &amp;basis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getBasisIndexInVK           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLatticeShape.html">LatticeShape</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lattice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBasis.html">Basis</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find out the index for a basis in V_{K} 
</div>
</div><p>
<a class="anchor" name="cfed0b2a759fecb4de581223ec6b5a29"></a><!-- doxytag: member="recursiveCalculation.h::setUpRecursion" ref="cfed0b2a759fecb4de581223ec6b5a29" args="(LatticeShape &amp;lattice, InteractionData &amp;interactionData, Basis &amp;initialSites, RecursionData &amp;rd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setUpRecursion           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLatticeShape.html">LatticeShape</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lattice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInteractionData.html">InteractionData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interactionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBasis.html">Basis</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>initialSites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRecursionData.html">RecursionData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>recursionData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set up the precondition for the recursive calculations: fromRightToCenter and fromLeftToCenter 
<p>
To find out KRightStart, we start from V_{KRightStop}=[ v_{KRightStop}, v_{KRightStop+1}, ..., v_{KRightStop+maxDistance-1} ]. We can let K = KRightStop+maxDistance-1 and increase K by maxDistance each time until K &gt; Kmax, then the value of KRightStart is given by current_value_of_K - maxDistance - (maxDistance-1) 
</div>
</div><p>
<a class="anchor" name="f519514f8f6d6155af66d593f73e4e1d"></a><!-- doxytag: member="recursiveCalculation.h::solveDenseLinearEqs" ref="f519514f8f6d6155af66d593f73e4e1d" args="(CDMatrix &amp;A, CDMatrix &amp;B, CDMatrix &amp;X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveDenseLinearEqs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
solve the linear equation A*X = B 
</div>
</div><p>
<a class="anchor" name="e097b7a86f8594f1b00c6f8c99c17a08"></a><!-- doxytag: member="recursiveCalculation.h::solveVKCenter" ref="e097b7a86f8594f1b00c6f8c99c17a08" args="(RecursionData &amp;recursionData, dcomplex z, CDMatrix &amp;ATildeKLeftStop, CDMatrix &amp;AKRightStop, CDMatrix &amp;VKCenter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveVKCenter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRecursionData.html">RecursionData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>recursionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#9cd6246c3665bdbc2377b9c902f311e3">dcomplex</a>&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ATildeKLeftStop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>AKRightStop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#faef33e67aa5007ecfd81e470e5fcf05">CDMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>VKCenter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
solve for the Vector VKCenter given AKRightStop and ATildeKLeftStop<p>
W_{KCenter}*V_{KCenter} = alpha_{KCenter}*V_{KCenter-maxDistance} + beta_{KCenter}*V_{KCenter+maxDistance} + C Knowing A_{KRightStop} = A_{KCenter+maxDistance}, we can obtain V_{KCenter+maxDistance} by V_{KCenter+maxDistance} = A_{KRightStop}*V_{KCenter}<p>
Knowing ATilde_{KLeftStop} = ATilde_{KCenter-maxDistance}, we have V_{KCenter-maxDistance} = ATilde_{KLeftStop}*V_{KCenter}<p>
Substituting the above two equations into the first equation, we obtain [ W_{KCenter} - alpha_{KCenter}*ATilde_{KLeftStop} - beta_{KCenter}*A_{KRightStop}]*V_{KCenter} = C<p>
Then V_{KCenter} can be obtained by solving the above linear equation 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 30 23:52:13 2014 for CalculateGreenFunction by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
