\section{src/basis\_\-set/basis.cpp File Reference}
\label{basis_8cpp}\index{src/basis_set/basis.cpp@{src/basis\_\-set/basis.cpp}}
{\tt \#include \char`\"{}basis.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
void \bf{get\-Lattice\-Index} (\bf{Lattice\-Shape} \&lattice, \bf{Basis} \&basis, int \&site1, int \&site2)
\item 
double \bf{distance} (\bf{Basis} \&b1, \bf{Basis} \&b2)
\item 
void \bf{print\-Neighbors} (\bf{Neighbors} \&neighbors)
\item 
void \bf{generate\-Neighbors} (\bf{Basis} basis, int distance, \bf{Lattice\-Shape} \&lattice, \bf{Neighbors} \&neighbors)
\item 
void \bf{generate\-Index\-Matrix} (\bf{Lattice\-Shape} \&lattice)
\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
std::vector$<$ std::vector$<$ \bf{Basis\-Pointer} $>$ $>$ \bf{Vto\-G}
\item 
std::vector$<$ int $>$ \bf{Dims\-Of\-V}
\item 
\bf{IMatrix} \bf{Index\-Matrix}
\end{CompactItemize}


\subsection{Function Documentation}
\index{basis.cpp@{basis.cpp}!distance@{distance}}
\index{distance@{distance}!basis.cpp@{basis.cpp}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}double distance (\bf{Basis} \& {\em b1}, \bf{Basis} \& {\em b2})}\label{basis_8cpp_e9c7fa4f242e67d65fcefe7f853523f8}


\index{basis.cpp@{basis.cpp}!generateIndexMatrix@{generateIndexMatrix}}
\index{generateIndexMatrix@{generateIndexMatrix}!basis.cpp@{basis.cpp}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void generate\-Index\-Matrix (\bf{Lattice\-Shape} \& {\em lattice})}\label{basis_8cpp_5104afb9f6ff60c6903d70feb9d37576}


\index{basis.cpp@{basis.cpp}!generateNeighbors@{generateNeighbors}}
\index{generateNeighbors@{generateNeighbors}!basis.cpp@{basis.cpp}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void generate\-Neighbors (\bf{Basis} {\em basis}, int {\em distance}, \bf{Lattice\-Shape} \& {\em lattice}, \bf{Neighbors} \& {\em neighbors})}\label{basis_8cpp_dc70ab0ee39f9e60d46e18d6c26e4156}


Given a two-particle state, this function generate its neighbors that at some distance. The distance can take both positive and negative values. If distance $<$ 0, we call the neighbors left neighbors. If distance $>$ 0, we call the neighbors right neighbors. \index{basis.cpp@{basis.cpp}!getLatticeIndex@{getLatticeIndex}}
\index{getLatticeIndex@{getLatticeIndex}!basis.cpp@{basis.cpp}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void get\-Lattice\-Index (\bf{Lattice\-Shape} \& {\em lattice}, \bf{Basis} \& {\em basis}, int \& {\em site1}, int \& {\em site2})}\label{basis_8cpp_c79dd08aec760821bccb305800cd4887}


In a lattice, we give each site an index. For example, in 1D, we can use the index numbers 0 ... xmax to denote each sites. In 2D, we still want to use a single number to denote each lattice site, so we assign a number to each position (x,y). This is a mapping from (x, y) to a positive integer nth.

Given a basis (1D or 2D), this function return the corresponding lattice index. \index{basis.cpp@{basis.cpp}!printNeighbors@{printNeighbors}}
\index{printNeighbors@{printNeighbors}!basis.cpp@{basis.cpp}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void print\-Neighbors (\bf{Neighbors} \& {\em neighbors})}\label{basis_8cpp_11e3efa510cb0e8f09015278644f1c0d}




\subsection{Variable Documentation}
\index{basis.cpp@{basis.cpp}!DimsOfV@{DimsOfV}}
\index{DimsOfV@{DimsOfV}!basis.cpp@{basis.cpp}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}std::vector$<$int$>$ \bf{Dims\-Of\-V}}\label{basis_8cpp_8d39fd76366dc1dd8e6c4c076255c87f}


\index{basis.cpp@{basis.cpp}!IndexMatrix@{IndexMatrix}}
\index{IndexMatrix@{IndexMatrix}!basis.cpp@{basis.cpp}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\bf{IMatrix} \bf{Index\-Matrix}}\label{basis_8cpp_a3876e258afaecf57418f18355f5ea17}


\index{basis.cpp@{basis.cpp}!VtoG@{VtoG}}
\index{VtoG@{VtoG}!basis.cpp@{basis.cpp}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}std::vector$<$ std::vector$<$\bf{Basis\-Pointer}$>$ $>$ \bf{Vto\-G}}\label{basis_8cpp_e21b844099197f70cbf20820b1ec46e8}


